"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionProvider = void 0;
const Settings_1 = require("../Settings");
const Errors_1 = require("../Core/Errors");
const Trig_1 = require("../Functions/Trig");
const Trig_hyperbolic_1 = require("../Functions/Trig.hyperbolic");
const Core_1 = require("../Functions/Core");
const expand_1 = require("../Functions/Core/math/expand");
class FunctionProvider {
    constructor() {
        this.functions = {
            'cos': [Trig_1.Trig.cos, 1],
            'sin': [Trig_1.Trig.sin, 1],
            'tan': [Trig_1.Trig.tan, 1],
            'sec': [Trig_1.Trig.sec, 1],
            'csc': [Trig_1.Trig.csc, 1],
            'cot': [Trig_1.Trig.cot, 1],
            'acos': [Trig_1.Trig.acos, 1],
            'asin': [Trig_1.Trig.asin, 1],
            'atan': [Trig_1.Trig.atan, 1],
            'arccos': [Trig_1.Trig.acos, 1],
            'arcsin': [Trig_1.Trig.asin, 1],
            'arctan': [Trig_1.Trig.atan, 1],
            'asec': [Trig_1.Trig.asec, 1],
            'acsc': [Trig_1.Trig.acsc, 1],
            'acot': [Trig_1.Trig.acot, 1],
            'atan2': [Trig_1.Trig.atan2, 2],
            'acoth': [Trig_hyperbolic_1.TrigHyperbolic.acoth, 1],
            'asech': [Trig_hyperbolic_1.TrigHyperbolic.asech, 1],
            'acsch': [Trig_hyperbolic_1.TrigHyperbolic.acsch, 1],
            'sinh': [Trig_hyperbolic_1.TrigHyperbolic.sinh, 1],
            'cosh': [Trig_hyperbolic_1.TrigHyperbolic.cosh, 1],
            'tanh': [Trig_hyperbolic_1.TrigHyperbolic.tanh, 1],
            'asinh': [Trig_hyperbolic_1.TrigHyperbolic.asinh, 1],
            'sech': [Trig_hyperbolic_1.TrigHyperbolic.sech, 1],
            'csch': [Trig_hyperbolic_1.TrigHyperbolic.csch, 1],
            'coth': [Trig_hyperbolic_1.TrigHyperbolic.coth, 1],
            'acosh': [Trig_hyperbolic_1.TrigHyperbolic.acosh, 1],
            'atanh': [Trig_hyperbolic_1.TrigHyperbolic.atanh, 1],
            'log10': [null, 1],
            'exp': [Core_1.exp, 1],
            'radians': [Core_1.radians, 1],
            'degrees': [Core_1.degrees, 1],
            'min': [Core_1.min, -1],
            'max': [Core_1.max, -1],
            'erf': [null, 1],
            'floor': [null, 1],
            'ceil': [null, 1],
            'trunc': [null, 1],
            'Si': [null, 1],
            'step': [null, 1],
            'rect': [null, 1],
            'sinc': [Core_1.sinc, 1],
            'tri': [null, 1],
            'sign': [Core_1.sign, 1],
            'Ci': [null, 1],
            'Ei': [null, 1],
            'Shi': [null, 1],
            'Chi': [null, 1],
            'Li': [null, 1],
            'fib': [null, 1],
            'fact': [Core_1.factorial, 1],
            'factorial': [Core_1.factorial, 1],
            'continued_fraction': [Core_1.continued_fraction, [1, 2]],
            'dfactorial': [null, 1],
            'gamma_incomplete': [null, [1, 2]],
            'round': [Core_1.round, [1, 2]],
            'scientific': [Core_1.scientific, [1, 2]],
            'mod': [Core_1.mod, 2],
            'pfactor': [Core_1.pfactor, 1],
            'vector': [Core_1.vector, -1],
            'matrix': [Core_1.matrix, -1],
            'Set': [Core_1.set, -1],
            'imatrix': [Core_1.imatrix, -1],
            'parens': [Core_1.parens, -1],
            'sqrt': [Core_1.sqrt, 1],
            'cbrt': [Core_1.cbrt, 1],
            'nthroot': [Core_1.nthroot, 2],
            'log': [Core_1.log, [1, 2]],
            'expand': [expand_1.expandall, 1],
            'abs': [Core_1.abs, 1],
            'invert': [Core_1.invert, 1],
            'determinant': [Core_1.determinant, 1],
            'size': [Core_1.size, 1],
            'transpose': [Core_1.transpose, 1],
            'dot': [Core_1.dot, 2],
            'cross': [Core_1.cross, 2],
            'vecget': [Core_1.vecget, 2],
            'vecset': [Core_1.vecget, 3],
            'vectrim': [Core_1.vectrim, [1, 2]],
            'matget': [Core_1.matget, 3],
            'matset': [Core_1.matset, 4],
            'matgetrow': [Core_1.matgetrow, 2],
            'matsetrow': [Core_1.matsetrow, 3],
            'matgetcol': [Core_1.matgetcol, 2],
            'matsetcol': [Core_1.matsetcol, 3],
            'rationalize': [Core_1.rationalize, 1],
            'IF': [Core_1.IF, 3],
            'is_in': [Core_1.is_in, 2],
            //imaginary support
            'realpart': [Core_1.realpart, 1],
            'imagpart': [Core_1.imagpart, 1],
            'conjugate': [Core_1.conjugate, 1],
            'arg': [Core_1.arg, 1],
            'polarform': [Core_1.polarform, 1],
            'rectform': [Core_1.rectform, 1],
            'sort': [Core_1.sort, [1, 2]],
            'integer_part': [null, 1],
            'union': [Core_1.union, 2],
            'contains': [Core_1.contains, 2],
            'intersection': [Core_1.intersection, 2],
            'difference': [Core_1.difference, 2],
            'intersects': [Core_1.intersects, 2],
            'is_subset': [Core_1.is_subset, 2],
            //system support
            'print': [Core_1.print, -1]
        };
    }
    getFunctionDescriptor(name) {
        return this.functions[name];
    }
    /**
     * Searches for function in FUNCTION_MODULES by name, throws error was not found
     * @param name
     * @return {(...args: any) => any}
     * @throws
     */
    findFunction(name) {
        let modules = Settings_1.Settings.FUNCTION_MODULES;
        const l = modules.length;
        for (let i = 0; i < l; i++) {
            let module = modules[i];
            if (name in module) {
                return module[name];
            }
        }
        (0, Errors_1.err)(`The function ${name} is undefined!`);
    }
    getFunctionDescriptors() {
        return this.functions;
    }
    setFunctionDescriptor(name, descriptor) {
        this.functions[name] = descriptor;
    }
    removeFunctionDescriptor(name) {
        delete this.functions[name];
    }
    /**
     * provide a mechanism for accessing functions directly. Not yet complete!!!
     * Some functions will return undefined. This can maybe just remove the
     * function object at some point when all functions are eventually
     * housed in the global function object. Returns ALL parser available
     * functions. Parser.functions may not contain all functions
     * @return {Record<string, (...args: any[]) => any>}
     */
    importFunctions() {
        let o = {};
        let functions = this.functions;
        for (let x in functions) {
            o[x] = functions[x][0];
        }
        return o;
    }
}
exports.FunctionProvider = FunctionProvider;
//# sourceMappingURL=FunctionProvider.js.map