import { SettingsType } from "../Settings";
import { Symbol } from '../Types/Symbol';
import { decompose_fn, getCoeffs, isFraction, isNegative, isNumericSymbol, nroots, scientificToDecimal, separate } from './Utils-js';
import { arraySum } from './Utils.Symbol';
export { decompose_fn, arraySum, getCoeffs, isFraction, isNegative, isNumericSymbol, nroots, scientificToDecimal, separate };
/**
 * Checks to see that all symbols in array are the same
 * @param {{ equals() }[]} arr
 * @returns {boolean}
 */
export declare function allSame(arr: Symbol[]): boolean;
/**
 * Checks to see if an array contains only numeric values
 * @param {Array} arr
 */
export declare function allNumeric(arr: string[]): boolean;
/**
 * Converts function arguments to an array. Now used by gcd and lcm in Algebra.js :)
 * @deprecated Just use rest syntax: ...args!
 * @param {Array|object} obj
 */
export declare function arguments2Array(obj: any): never[];
/**
 * Fills numbers between array values
 * @param {number[]} arr
 * @param {Integer} slices
 */
export declare function arrayAddSlices(arr: any[], slices: number): any[];
/**
 * Clones array with clonable items
 * @param {Array} arr
 * @returns {Array}
 */
export declare function arrayClone<T extends {
    clone: () => T;
}>(arr: T[]): T[];
/**
 * Gets all the variables in an array of Symbols
 * @param {Symbol[]} arr
 */
export declare function arrayGetVariables(arr: Symbol[]): string[];
/**
 * Returns the minimum number in an array
 * @param {Array} arr
 * @returns {Number}
 */
export declare function arrayMax(arr: any[]): number;
/**
 * Returns the maximum number in an array
 * @param {Array} arr
 * @returns {Number}
 */
export declare function arrayMin(arr: any[]): number;
/**
 * Checks to see if two arrays are equal
 * @param {Array} arr1
 * @param {Array} arr2
 */
export declare function arrayEqual(arr1: any[], arr2: any[]): boolean;
/**
 * Strips duplicates out of an array
 * @param {Array} arr
 */
export declare function arrayUnique(arr: any[]): any[];
/**
 * Creates a temporary block in which one of the global settings is temporarily modified while
 * the function is called. For instance if you want to parse directly to a number rather than have a symbolic
 * answer for a period you would set PARSE2NUMBER to true in the block.
 * @example block('PARSE2NUMBER', function(){//symbol being parsed to number}, true);
 * @param settingsName
 * @param {Function} f
 * @param {boolean} opt - The value of the setting in the block
 * @param {string} obj - The obj of interest. Usually a Symbol but could be any object
 */
export declare function block<T>(settingsName: keyof SettingsType, f: () => T, opt?: any, obj?: object): T;
export declare function build(symbol: Symbol, arg_array?: string[]): Function;
/**
 * Sorts and array given 2 parameters
 * @param {String} a
 * @param {String} b
 */
export declare function comboSort(a: any[], b: any[]): any[][];
/**
 * Substitutes out variables for two symbols, parses them to a number and them compares them numerically
 * @param {Symbol} sym1
 * @param {Symbol} sym2
 * @param {string[]} vars - an optional array of variables to use
 * @returns {boolean}
 */
export declare function compare(sym1: Symbol, sym2: Symbol, vars: string[]): undefined;
export declare function convertToVector(x: any): any;
/**
 * the Parser uses this to check if it's allowed to convert the obj to type Symbol
 * @param {Object} obj
 * @returns {boolean}
 */
export declare function customType(obj?: any): any;
/**
 * Loops through each item in object and calls function with item as param
 * @param {Object|Array} obj
 * @param {Function} fn
 */
export declare function each(obj: any, fn: (index: number | string) => void): void;
/**
 * As the name states. It forces evaluation of the expression
 * @param {Symbol} symbol
 * @param {Symbol} o
 */
export declare function evaluate(symbol: Symbol, o?: any): any;
/**
 * Checks to see if a number is an even number
 * @param {Number} num
 * @returns {boolean}
 */
export declare function even(num: number): boolean;
/**
 * Checks to see if a fraction is divisible by 2
 * @param {number} num
 * @returns {boolean}
 */
export declare function evenFraction(num: number): boolean;
/**
 * Fills holes in an array with zero symbol or generates one with n zeroes
 * @param {Array} arr
 * @param {Number} n
 */
export declare function fillHoles(arr: any[], n: number): any[];
/**
 * Returns the first encountered item in an object. Items do not have a fixed order in objects
 * so only use if you need any first random or if there's only one item in the object
 * @param {object} obj
 * @param {boolean} key Return this key as first object
 * @param {boolean} both
 * @returns {*}
 */
export declare function firstObject(obj: any, key?: boolean, both?: boolean): any;
/**
 * A helper function to replace multiple occurences in a string. Takes multiple arguments
 * @example format('{0} nice, {0} sweet', 'something')
 * //returns 'something nice, something sweet'
 */
export declare function format(str: string, ...args: any): string;
/**
 * Generates prime numbers up to a specified number
 * @param {Number} upto
 */
export declare function generatePrimes(upto: number): void;
/**
 * @param {String} str
 * @returns {String} - returns a formatted string surrounded by brackets
 */
export declare function inBrackets(str: string): string;
/**
 * Checks to see if the object provided is an Array
 * @param {Object} arr
 */
export declare function isArray(arr: any): boolean;
/**
 * Checks to see if the object provided is a Matrix
 * @param {Object} obj
 */
export declare function isMatrix(obj: any): boolean;
/**
 * Checks to see if the object provided is an Expression
 * @param {Object} obj
 */
export declare function isExpression(obj: any): boolean;
/**
 * Checks to see if the object provided is a Symbol
 * @param {Object} obj
 */
export declare function isSymbol(obj: any): boolean;
/**
 * Checks to see if a number is an integer
 * @param {number} value
 */
export declare function isInt(value: number | string): boolean;
/**
 * Checks if number is a prime number
 * @param {Number} n - the number to be checked
 */
export declare function isPrime(n: number): boolean;
/**
 * Checks if n is a number
 * @param {any} n
 */
export declare function isNumber(n: string): boolean;
/**
 * Generates an object with known variable value for evaluation
 * @param key
 * @param {any} value Any stringifyable object
 * @returns {Object}
 */
export declare function knownVariable(key: string, value: any): any;
/**
 * Rounds a number up to x decimal places
 * @param {number} x
 * @param {number} s
 */
export declare function nround(x: string, s?: number): string | number;
/**
 * Enforces rule: "must start with a letter or underscore and
 * can have any number of underscores, letters, and numbers thereafter."
 * @param {string} name The name of the symbol being checked
 * @param {string} typ - The type of symbols that's being validated
 * @throws {InvalidVariableNameError}  - Throws an exception on fail
 */
export declare function validateName(name: string, typ?: string): void;
/**
 * Used to pass warnings or low severity errors about the library
 * @param msg
 */
export declare const WARNINGS: string[];
export declare function warn(msg: string): void;
/**
 * Removes an item from either an array or an object. If the object is an array, the index must be
 * specified after the array. If it's an object then the key must be specified
 * @param {Object|Array} obj
 * @param {Integer} indexOrKey
 */
export declare function remove(obj: any, indexOrKey: number | string): any;
/**
 * Checks to see if a symbol is a variable with no multiplier nor power
 * @param {Symbol} symbol
 */
export declare function isVariableSymbol(symbol: Symbol): any;
/**
 *
 * Checks to see if the object provided is a Vector
 * @param {Object} obj
 */
export declare function isVector(obj: any): boolean;
/**
 * Generates an array with values within a range. Multiplies by a step if provided
 * @param {Number} start
 * @param {Number} end
 * @param {Number} step
 */
export declare function range(start: number, end: number, step?: number): number[];
export declare function pretty_print(o: any): string;
/**
 * Checks to see if all arguments are numbers
 * @param {Symbol[]} args
 */
export declare function allNumbers(args: Symbol[]): boolean;
export declare function allConstants(args: any): boolean;
/**
 * Checks to see if numbers are both negative or are both positive
 * @param {Number} a
 * @param {Number} b
 * @returns {boolean}
 */
export declare function sameSign(a: number, b: number): boolean;
/**
 * A helper function to replace parts of string
 * @param {String} str - The original string
 * @param {Integer} from - The starting index
 * @param {Integer} to - The ending index
 * @param {String} with_str - The replacement string
 * @returns {String} - A formatted string
 */
export declare function stringReplace(str: string, from: number, to: number, with_str: string): string;
export declare function text(obj: any, option?: any, useGroup?: boolean, decp?: any): string;
/**
 * Returns an array of all the keys in an array
 * @param {Object} obj
 * @returns {Array}
 */
export declare const keys: {
    (o: object): string[];
    (o: {}): string[];
};
/**
 * This method traverses the symbol structure and grabs all the variables in a symbol. The variable
 * names are then returned in alphabetical order.
 * @param {Symbol} obj
 * @param {Boolean} poly
 * @param {Object} vars - An object containing the variables. Do not pass this in as it generated
 * automatically. In the future this will be a Collector object.
 * @returns {String[]} - An array containing variable names
 */
export declare function variables(obj: Symbol, poly?: boolean, vars?: {
    c: string[];
}): string[];
