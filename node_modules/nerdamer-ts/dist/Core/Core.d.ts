import { FunctionProvider } from '../Providers/FunctionProvider';
import { OperatorDictionary } from '../Providers/OperatorDictionary';
import { VariableDictionary } from '../Providers/VariableDictionary';
import { Expression } from '../Parser/Expression';
import { Parser } from '../Parser/Parser';
import { Symbol } from '../Types/Symbol';
import * as Utils from './Utils';
import { err } from './Errors';
import { Groups } from '../Types/Groups';
import { Frac } from '../Types/Frac';
import { Vector } from '../Types/Vector';
import { Matrix } from '../Types/Matrix';
import Scientific from '../Types/Scientific';
import { LaTeX } from '../LaTeX/LaTeX';
import bigDec from 'decimal.js';
import * as exceptions from './Errors';
declare type UtilsType = typeof Utils & {
    clearU: (u: string) => void;
    getU: (symbol: Symbol) => string;
    importFunctions: () => Record<string, ((...any: any[]) => any)>;
    reserveNames: (module: object | string) => void;
    isReserved: (name: string) => boolean;
    round: (x: string, s?: number) => number | string;
};
export declare class Core {
    Utils: UtilsType;
    groups: typeof Groups;
    Symbol: typeof Symbol;
    Expression: typeof Expression;
    Frac: typeof Frac;
    Vector: typeof Vector;
    Matrix: typeof Matrix;
    Parser: typeof Parser;
    Scientific: typeof Scientific;
    Math2: {
        csc: (x: any) => number;
        sec: (x: any) => number;
        cot: (x: any) => number;
        acsc: (x: any) => number;
        asec: (x: any) => number;
        acot: (x: any) => number;
        erf: (x: any) => number;
        diff: (f: any) => (x: any) => number;
        median: (...values: any[]) => any;
        fromContinued: (contd: any) => number;
        continuedFraction: (n: any, x: any) => {
            whole: number;
            sign: number;
            fractions: never[];
        };
        bigpow: (n: any, p: any) => Frac;
        gamma: (z: any) => any;
        bigfactorial: (x: any) => Frac;
        bigLog: (x: any) => any;
        factorial: (x: any) => any;
        dfactorial: (x: any) => Frac;
        GCD: (...args: any[]) => number;
        QGCD: (...args: any[]) => any;
        LCM: (a: any, b: any) => number;
        pow: (b: any, e: any) => number;
        factor: (n: any) => Symbol;
        sfactor: (n: any, factors: object) => object;
        ifactor: (n: any) => object;
        boxfactor: (n: any, max: any) => any[];
        fib: (n: any) => number;
        mod: (x: any, y: any) => number;
        integer_part: (x: any) => number;
        simpson: (f: any, a: any, b: any, step: any) => number;
        num_integrate: (f: Function, a: number, b: number, tol: number, maxdepth: number) => number;
        Ci: (x: any) => number;
        Si: (x: any) => number;
        Ei: (x: any) => number;
        Shi: (x: any) => number;
        Chi: (x: any) => number;
        Li: (x: any) => number;
        gamma_incomplete: (n: any, x?: number) => number;
        step: (x: any) => 1 | 0 | 0.5;
        rect: (x: any) => any;
        sinc: (x: any) => number;
        tri: (x: any) => number;
        nthroot: (A: any, n: any) => any;
        sqrt: (n: any) => Frac;
    };
    LaTeX: typeof LaTeX;
    PARSER: Parser;
    PARENTHESIS: string;
    Settings: import("../Settings").SettingsType;
    err: typeof err;
    bigInt: {
        (v: any, radix: any): any;
        one: any;
        zero: any;
        minusOne: any;
        max: (a: any, b: any) => any;
        min: (a: any, b: any) => any;
        gcd: (a: any, b: any) => any;
        lcm: (a: any, b: any) => any;
        isInstance(x: any): boolean;
        randBetween: (a: any, b: any) => any;
        fromArray(digits: any, base: any, isNegative: any): any;
    };
    bigDec: typeof bigDec;
    exceptions: typeof exceptions;
    functionProvider: FunctionProvider;
    operators: OperatorDictionary;
    variableDictionary: VariableDictionary;
    EXPRESSIONS: any[];
    peekers: any;
    constructor();
}
export {};
