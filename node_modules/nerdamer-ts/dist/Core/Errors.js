"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.err = exports.PreprocessorError = exports.InvalidVariableNameError = exports.UnexpectedTokenError = exports.InfiniteLoopError = exports.SolveError = exports.NerdamerValueError = exports.ValueLimitExceededError = exports.DimensionError = exports.OutOfRangeError = exports.OperatorError = exports.ParityError = exports.NerdamerTypeError = exports.MaximumIterationsReached = exports.OutOfFunctionDomainError = exports.UndefinedError = exports.ParseError = exports.DivisionByZero = void 0;
//Is thrown for division by zero
const Settings_1 = require("../Settings");
class DivisionByZero extends Error {
    constructor() {
        super(...arguments);
        this.name = 'DivisionByZero';
    }
}
exports.DivisionByZero = DivisionByZero;
// Is throw if an error occured during parsing
class ParseError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'ParseError';
    }
}
exports.ParseError = ParseError;
// Is thrown if the expression results in undefined
class UndefinedError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'UndefinedError';
    }
}
exports.UndefinedError = UndefinedError;
// Is throw input is out of the function domain
class OutOfFunctionDomainError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'OutOfFunctionDomainError';
    }
}
exports.OutOfFunctionDomainError = OutOfFunctionDomainError;
// Is throw if a function exceeds x amount of iterations
class MaximumIterationsReached extends Error {
    constructor() {
        super(...arguments);
        this.name = 'MaximumIterationsReached';
    }
}
exports.MaximumIterationsReached = MaximumIterationsReached;
// Is thrown if the parser receives an incorrect type
class NerdamerTypeError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'NerdamerTypeError';
    }
}
exports.NerdamerTypeError = NerdamerTypeError;
// Is thrown if bracket parity is not correct
class ParityError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'ParityError';
    }
}
exports.ParityError = ParityError;
// Is thrown if an unexpectd or incorrect operator is encountered
class OperatorError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'OperatorError';
    }
}
exports.OperatorError = OperatorError;
// Is thrown if an index is out of range.
class OutOfRangeError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'OutOfRangeError';
    }
}
exports.OutOfRangeError = OutOfRangeError;
// Is thrown if dimensions are incorrect. Mostly for matrices
class DimensionError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'DimensionError';
    }
}
exports.DimensionError = DimensionError;
// Is thrown if the limits of the library are exceeded for a function
// This can be that the function become unstable passed a value
class ValueLimitExceededError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'ValueLimitExceededError';
    }
}
exports.ValueLimitExceededError = ValueLimitExceededError;
// Is throw if the value is an incorrect LH or RH value
class NerdamerValueError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'NerdamerValueError';
    }
}
exports.NerdamerValueError = NerdamerValueError;
// Is thrown if the value is an incorrect LH or RH value
class SolveError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'SolveError';
    }
}
exports.SolveError = SolveError;
// Is thrown for an infinite loop
class InfiniteLoopError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'InfiniteLoopError';
    }
}
exports.InfiniteLoopError = InfiniteLoopError;
// Is thrown if an operator is found when there shouldn't be one
class UnexpectedTokenError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'UnexpectedTokenError';
    }
}
exports.UnexpectedTokenError = UnexpectedTokenError;
// Is thrown if variable name violates naming rule
class InvalidVariableNameError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'InvalidVariableNameError';
    }
}
exports.InvalidVariableNameError = InvalidVariableNameError;
class PreprocessorError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'PreprocessorError';
    }
}
exports.PreprocessorError = PreprocessorError;
/**
 * Use this when errors are suppressible
 * @param {String} message
 * @param {object} errorObj
 */
function err(message, errorObj) {
    if (!Settings_1.Settings.suppress_errors) {
        if (errorObj) {
            throw new errorObj(message);
        }
        else {
            throw new Error(message);
        }
    }
}
exports.err = err;
//# sourceMappingURL=Errors.js.map