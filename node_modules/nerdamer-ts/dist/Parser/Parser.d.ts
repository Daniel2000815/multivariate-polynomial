/**
 *
 * @param {string | Symbol} e
 * @param {object} substitutions
 * @return {*}
 */
export function parse(e: string | Symbol, substitutions?: object): any;
/**
 * As the name states. It forces evaluation of the expression
 * @param {string} expression
 * @param {Symbol} o
 * @deprecated use Utils.evaluate instead
 */
export function evaluate(expression: string, o?: Symbol): any;
export class Parser {
    constructor(tokenizer: any, operators: any, functionProvider: any, variables: any, peekers: any, units: any);
    classes: {
        Collection: typeof Collection;
        Slice: typeof Slice;
        Token: typeof Token;
    };
    trig: {
        cos: (symbol: any) => any;
        sin: (symbol: any) => any;
        tan: (symbol: any) => any;
        sec: (symbol: any) => any;
        csc: (symbol: any) => any;
        cot: (symbol: any) => any;
        acos: (symbol: any, ...args: any[]) => any;
        asin: (symbol: any, ...args: any[]) => any;
        atan: (symbol: any, ...args: any[]) => any;
        asec: (symbol: any, ...args: any[]) => any;
        acsc: (symbol: any, ...args: any[]) => any;
        acot: (symbol: any, ...args: any[]) => any;
        atan2: (a: any, b: any, ...args: any[]) => Symbol;
    };
    trigh: {
        cosh: (symbol: any, ...args: any[]) => any;
        sinh: (symbol: any, ...args: any[]) => any;
        /** @property {Tokenizer} tokenizer */
        tanh: (symbol: any, ...args: any[]) => any;
        sech: (symbol: any, ...args: any[]) => any;
        csch: (symbol: any, ...args: any[]) => any;
        coth: (symbol: any, ...args: any[]) => any;
        acosh: (symbol: any, ...args: any[]) => any;
        asinh: (symbol: any, ...args: any[]) => any;
        atanh: (symbol: any, ...args: any[]) => any;
        asech: (symbol: any, ...args: any[]) => any;
        acsch: (symbol: any, ...args: any[]) => any;
        acoth: (symbol: any, ...args: any[]) => any;
    };
    error: typeof err;
    symfunction: typeof symfunction;
    /** @property {Tokenizer} tokenizer */
    tokenizer: any;
    /** @property {OperatorDictionary} operators */
    operators: any;
    /** @property {FunctionProvider} functionProvider */
    functionProvider: any;
    /** @property {VariableDictionary} variables */
    variables: any;
    bin: {};
    peekers: any;
    units: any;
    getAction(name: any): any;
    setAction(name: any, func: any): void;
    setOperator(operator: any, action?: undefined, shift?: undefined): void;
    initConstants(): void;
    parse(e: any, substitutions?: {}): Symbol;
    /**
     * Tokenizes the string
     * @param {String} e
     * @returns {Token[]}
     */
    tokenize(e: string): Token[];
    /**
     * Puts token array in Reverse Polish Notation
     * @param {Token[]} tokens
     * @returns {Token[]}
     */
    toRPN(tokens: Token[]): Token[];
    /**
     * Parses the tokens
     * @param {Token[]} rpn
     * @param {object} substitutions
     * @returns {Symbol}
     */
    parseRPN(rpn: Token[], substitutions: object): Symbol;
    /**
     * This method is supposed to behave similarly to the override method but it does not override
     * the existing function rather it only extends it
     * @param {String} what
     * @param {Function} with_what
     * @param {boolean} force_call
     */
    extend(what: string, with_what: Function, force_call: boolean): void;
    /**
     * This method gives the ability to override operators with new methods.
     * @param {String} which
     * @param {Function} with_what
     */
    override(which: string, with_what: Function): void;
    /**
     * Restores a previously overridden operator
     * @param {String} what
     */
    restore(what: string): void;
    clean(symbol: any): any;
    /**
     * An internal function call for the Parser. This will either trigger a real
     * function call if it can do so or just return a symbolic representation of the
     * function using symfunction.
     * @param {String} fn_name
     * @param {Array} args
     * @param {int} allowed_args
     * @returns {Symbol}
     */
    callfunction(fn_name: string, args: any[], allowed_args?: any): Symbol;
    getFunction(name: any): any;
    /**
     * TODO: Switch to Parser.tokenize for this method
     * Reads a string into an array of Symbols and operators
     * @param {String} expression_string
     * @returns {Array}
     */
    toObject(expression_string: string): any[];
    remove_redundant_powers: (arr: any) => any[];
    chunkAtCommas(arr: any): never[][];
    rem_brackets(str: any): any;
    /**
     * Convert expression or object to LaTeX
     * @param {string} expression_or_obj
     * @param {ConvertToLaTeXOptions} opt
     * @returns {string}
     */
    toTeX(expression_or_obj: string, opt: any): string;
    isOperator(name: any): any;
    getOperatorsClass(): any;
    getBrackets(): any;
    get functions(): any;
    getFunctions(): any;
    getFunctionProvider(): any;
    comma(a: any, b: any): any;
    slice(a: any, b: any): Slice;
    equals(a: any, b: any): any;
    percent(a: any): Symbol;
    assign(a: any, b: any): any;
    function_assign(a: any, b: any): any;
    bool2Symbol(x: any): Symbol;
    eq(a: any, b: any): Symbol;
    gt(a: any, b: any): Symbol;
    gte(a: any, b: any): Symbol;
    lt(a: any, b: any): Symbol;
    lte(a: any, b: any): Symbol;
    factorial(a: any): Symbol;
    dfactorial(a: any): Symbol;
    expand(symbol: any, opt?: undefined): any;
    round(x: any, s: any): undefined;
    cbrt(symbol: any): Symbol;
    abs(symbol: any): any;
    log(symbol: any, base: any): Symbol;
    rationalize(symbol: any): Symbol;
    nthroot(num: any, p: any, prec: any, asbig: any): Symbol;
    arg(symbol: any): Symbol;
    conjugate(symbol: any): Symbol;
    imagpart(symbol: any): globalThis.Symbol;
    realpart(symbol: any): globalThis.Symbol;
    sqrt(symbol: any): Symbol;
    multiply(a: any, b: any): Symbol;
    divide(a: any, b: any): Symbol;
    subtract(a: any, b: any): globalThis.Symbol;
    add(a: any, b: any): Symbol;
    pow(a: any, b: any): Symbol;
    mod(symbol1: any, symbol2: any): Symbol;
    tree(expression: any): any;
    setFunction(name: any, params_array: any, body: any): any;
}
/**
 *
 * @type {{parser: Parser}}
 */
export const ParseDeps: {
    parser: Parser;
};
import { Symbol } from "../Types/Symbol";
import { Collection } from "./Collection";
import { Slice } from "./Slice";
import { Token } from "./Token";
import { err } from "../Core/Errors";
import { symfunction } from "../Types/Symbol";
