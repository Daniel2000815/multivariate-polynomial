"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TrigHyperbolic = void 0;
//object for functions which handle hyperbolic trig
const Settings_1 = require("../Settings");
const Symbol_1 = require("../Types/Symbol");
const Utils_1 = require("../Core/Utils");
const Complex_1 = require("./Complex");
const Core_1 = require("./Core");
const Parser_1 = require("../Parser/Parser");
exports.TrigHyperbolic = {
    //container for hyperbolic trig function
    cosh: function (symbol) {
        var retval;
        if (Settings_1.Settings.PARSE2NUMBER) {
            if (symbol.isConstant())
                return new Symbol_1.Symbol(Math.cosh(symbol.valueOf()));
            if (symbol.isImaginary()) {
                return Complex_1.Complex.evaluate(symbol, 'cosh');
            }
        }
        return (0, Symbol_1.symfunction)('cosh', arguments);
    },
    sinh: function (symbol) {
        var retval;
        if (Settings_1.Settings.PARSE2NUMBER) {
            if (symbol.isConstant())
                return new Symbol_1.Symbol(Math.sinh(symbol.valueOf()));
            if (symbol.isImaginary()) {
                return Complex_1.Complex.evaluate(symbol, 'sinh');
            }
        }
        return retval = (0, Symbol_1.symfunction)('sinh', arguments);
    },
    tanh: function (symbol) {
        var retval;
        if (Settings_1.Settings.PARSE2NUMBER) {
            if (symbol.isConstant())
                return new Symbol_1.Symbol(Math.tanh(symbol.valueOf()));
            if (symbol.isImaginary()) {
                return Complex_1.Complex.evaluate(symbol, 'tanh');
            }
        }
        return retval = (0, Symbol_1.symfunction)('tanh', arguments);
    },
    sech: function (symbol) {
        var retval;
        if (Settings_1.Settings.PARSE2NUMBER) {
            if (symbol.isConstant()) {
                return new Symbol_1.Symbol(Math.sech(symbol.valueOf()));
            }
            if (symbol.isImaginary()) {
                return Complex_1.Complex.evaluate(symbol, 'sech');
            }
            return (0, Parser_1.parse)((0, Utils_1.format)('1/cosh({0})', symbol));
        }
        return retval = (0, Symbol_1.symfunction)('sech', arguments);
    },
    csch: function (symbol) {
        var retval;
        if (Settings_1.Settings.PARSE2NUMBER) {
            if (symbol.isConstant())
                return new Symbol_1.Symbol(Math.csch(symbol.valueOf()));
            if (symbol.isImaginary()) {
                return Complex_1.Complex.evaluate(symbol, 'csch');
            }
            return (0, Parser_1.parse)((0, Utils_1.format)('1/sinh({0})', symbol));
        }
        return retval = (0, Symbol_1.symfunction)('csch', arguments);
    },
    coth: function (symbol) {
        var retval;
        if (Settings_1.Settings.PARSE2NUMBER) {
            if (symbol.isConstant())
                return new Symbol_1.Symbol(Math.coth(symbol.valueOf()));
            if (symbol.isImaginary()) {
                return Complex_1.Complex.evaluate(symbol, 'coth');
            }
            return (0, Parser_1.parse)((0, Utils_1.format)('1/tanh({0})', symbol));
        }
        return retval = (0, Symbol_1.symfunction)('coth', arguments);
    },
    acosh: function (symbol) {
        var retval;
        if (Settings_1.Settings.PARSE2NUMBER && symbol.isImaginary())
            retval = Complex_1.Complex.evaluate(symbol, 'acosh');
        else if (Settings_1.Settings.PARSE2NUMBER)
            retval = (0, Parser_1.evaluate)((0, Parser_1.parse)((0, Utils_1.format)(Settings_1.Settings.LOG + '(({0})+sqrt(({0})^2-1))', symbol.toString())));
        else
            retval = (0, Symbol_1.symfunction)('acosh', arguments);
        return retval;
    },
    asinh: function (symbol) {
        var retval;
        if (Settings_1.Settings.PARSE2NUMBER && symbol.isImaginary())
            retval = Complex_1.Complex.evaluate(symbol, 'asinh');
        else if (Settings_1.Settings.PARSE2NUMBER)
            retval = (0, Parser_1.evaluate)((0, Parser_1.parse)((0, Utils_1.format)(Settings_1.Settings.LOG + '(({0})+sqrt(({0})^2+1))', symbol.toString())));
        else
            retval = (0, Symbol_1.symfunction)('asinh', arguments);
        return retval;
    },
    atanh: function (symbol) {
        var retval;
        if (Settings_1.Settings.PARSE2NUMBER && symbol.isImaginary())
            retval = Complex_1.Complex.evaluate(symbol, 'atanh');
        else if (Settings_1.Settings.PARSE2NUMBER) {
            retval = (0, Parser_1.evaluate)((0, Parser_1.parse)((0, Utils_1.format)('(1/2)*' + Settings_1.Settings.LOG + '((1+({0}))/(1-({0})))', symbol.toString())));
        }
        else
            retval = (0, Symbol_1.symfunction)('atanh', arguments);
        return retval;
    },
    asech: function (symbol) {
        var retval;
        if (Settings_1.Settings.PARSE2NUMBER && symbol.isImaginary())
            retval = Complex_1.Complex.evaluate(symbol, 'asech');
        else if (Settings_1.Settings.PARSE2NUMBER)
            retval = (0, Parser_1.evaluate)((0, Core_1.log)((0, Core_1.add)(symbol.clone().invert(), (0, Core_1.sqrt)((0, Core_1.subtract)((0, Core_1.pow)(symbol, new Symbol_1.Symbol(-2)), new Symbol_1.Symbol(1))))));
        else
            retval = (0, Symbol_1.symfunction)('asech', arguments);
        return retval;
    },
    acsch: function (symbol) {
        var retval;
        if (Settings_1.Settings.PARSE2NUMBER && symbol.isImaginary())
            retval = Complex_1.Complex.evaluate(symbol, 'acsch');
        else if (Settings_1.Settings.PARSE2NUMBER)
            retval = (0, Parser_1.evaluate)((0, Parser_1.parse)((0, Utils_1.format)(Settings_1.Settings.LOG + '((1+sqrt(1+({0})^2))/({0}))', symbol.toString())));
        else
            retval = (0, Symbol_1.symfunction)('acsch', arguments);
        return retval;
    },
    acoth: function (symbol) {
        var retval;
        if (Settings_1.Settings.PARSE2NUMBER && symbol.isImaginary())
            retval = Complex_1.Complex.evaluate(symbol, 'acoth');
        else if (Settings_1.Settings.PARSE2NUMBER) {
            if (symbol.equals(1))
                retval = Symbol_1.Symbol.infinity();
            else
                retval = (0, Parser_1.evaluate)((0, Core_1.divide)((0, Core_1.log)((0, Core_1.divide)((0, Core_1.add)(symbol.clone(), new Symbol_1.Symbol(1)), (0, Core_1.subtract)(symbol.clone(), new Symbol_1.Symbol(1)))), new Symbol_1.Symbol(2)));
        }
        else
            retval = (0, Symbol_1.symfunction)('acoth', arguments);
        return retval;
    }
};
//# sourceMappingURL=Trig.hyperbolic.js.map