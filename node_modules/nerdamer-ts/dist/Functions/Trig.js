"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Trig = void 0;
//object for functions which handle trig
const Symbol_1 = require("../Types/Symbol");
const Settings_1 = require("../Settings");
const decimal_js_1 = __importDefault(require("decimal.js"));
const Utils_1 = require("../Core/Utils");
const Math2_1 = require("./Math2");
const Complex_1 = require("./Complex");
const Errors_1 = require("../Core/Errors");
const Frac_1 = require("../Types/Frac");
const Core_1 = require("./Core");
const expand_1 = require("./Core/math/expand");
const Parser_1 = require("../Parser/Parser");
exports.Trig = {
    //container for trigonometric function
    cos: function (symbol) {
        if (symbol.equals('pi') && symbol.multiplier.den.equals(2))
            return new Symbol_1.Symbol(0);
        if (Settings_1.Settings.PARSE2NUMBER) {
            if (symbol.equals(new Symbol_1.Symbol(Settings_1.Settings.PI / 2)))
                return new Symbol_1.Symbol(0);
            if (symbol.isConstant()) {
                if (Settings_1.Settings.USE_BIG) {
                    return new Symbol_1.Symbol(decimal_js_1.default.cos(symbol.multiplier.toDecimal()));
                }
                return new Symbol_1.Symbol(Math.cos(symbol.valueOf()));
            }
            if (symbol.isImaginary()) {
                return Complex_1.Complex.evaluate(symbol, 'cos');
            }
        }
        if (symbol.equals(0))
            return new Symbol_1.Symbol(1);
        var retval, c = false, q = (0, Frac_1.getQuadrant)(symbol.multiplier.toDecimal()), m = symbol.multiplier.abs();
        symbol.multiplier = m;
        if (symbol.isPi() && symbol.isLinear()) {
            //return for 1 or -1 for multiples of pi
            if ((0, Utils_1.isInt)(m)) {
                retval = new Symbol_1.Symbol((0, Utils_1.even)(m) ? 1 : -1);
            }
            else {
                var n = Number(m.num), d = Number(m.den);
                if (d === 2)
                    retval = new Symbol_1.Symbol(0);
                else if (d === 3) {
                    retval = (0, Parser_1.parse)('1/2');
                    c = true;
                }
                else if (d === 4) {
                    retval = (0, Parser_1.parse)('1/sqrt(2)');
                    c = true;
                }
                else if (d === 6) {
                    retval = (0, Parser_1.parse)('sqrt(3)/2');
                    c = true;
                }
                else
                    retval = (0, Symbol_1.symfunction)('cos', [symbol]);
            }
        }
        if (c && (q === 2 || q === 3))
            retval.negate();
        if (!retval)
            retval = (0, Symbol_1.symfunction)('cos', [symbol]);
        return retval;
    },
    sin: function (symbol) {
        if (Settings_1.Settings.PARSE2NUMBER) {
            if (symbol.isConstant()) {
                if (symbol % Math.PI === 0) {
                    return new Symbol_1.Symbol(0);
                }
                if (Settings_1.Settings.USE_BIG) {
                    return new Symbol_1.Symbol(decimal_js_1.default.sin(symbol.multiplier.toDecimal()));
                }
                return new Symbol_1.Symbol(Math.sin(symbol.valueOf()));
            }
            if (symbol.isImaginary())
                return Complex_1.Complex.evaluate(symbol, 'sin');
        }
        if (symbol.equals(0))
            return new Symbol_1.Symbol(0);
        var retval, c = false, q = (0, Frac_1.getQuadrant)(symbol.multiplier.toDecimal()), sign = symbol.multiplier.sign(), m = symbol.multiplier.abs();
        symbol.multiplier = m;
        if (symbol.equals('pi'))
            retval = new Symbol_1.Symbol(0);
        else if (symbol.isPi() && symbol.isLinear()) {
            //return for 0 for multiples of pi
            if ((0, Utils_1.isInt)(m)) {
                retval = new Symbol_1.Symbol(0);
            }
            else {
                var n = m.num, d = m.den;
                if (d == 2) {
                    retval = new Symbol_1.Symbol(1);
                    c = true;
                }
                else if (d == 3) {
                    retval = (0, Parser_1.parse)('sqrt(3)/2');
                    c = true;
                }
                else if (d == 4) {
                    retval = (0, Parser_1.parse)('1/sqrt(2)');
                    c = true;
                }
                else if (d == 6) {
                    retval = (0, Parser_1.parse)('1/2');
                    c = true;
                }
                else
                    retval = (0, Core_1.multiply)(new Symbol_1.Symbol(sign), (0, Symbol_1.symfunction)('sin', [symbol]));
            }
        }
        if (!retval)
            retval = (0, Core_1.multiply)(new Symbol_1.Symbol(sign), (0, Symbol_1.symfunction)('sin', [symbol]));
        if (c && (q === 3 || q === 4))
            retval.negate();
        return retval;
    },
    tan: function (symbol) {
        if (Settings_1.Settings.PARSE2NUMBER) {
            if (symbol % Math.PI === 0 && symbol.isLinear()) {
                return new Symbol_1.Symbol(0);
            }
            if (symbol.isConstant()) {
                if (Settings_1.Settings.USE_BIG) {
                    return new Symbol_1.Symbol(decimal_js_1.default.tan(symbol.multiplier.toDecimal()));
                }
                return new Symbol_1.Symbol(Math.tan(symbol.valueOf()));
            }
            if (symbol.isImaginary())
                return Complex_1.Complex.evaluate(symbol, 'tan');
        }
        var retval, c = false, q = (0, Frac_1.getQuadrant)(symbol.multiplier.toDecimal()), m = symbol.multiplier;
        symbol.multiplier = m;
        if (symbol.isPi() && symbol.isLinear()) {
            //return 0 for all multiples of pi
            if ((0, Utils_1.isInt)(m)) {
                retval = new Symbol_1.Symbol(0);
            }
            else {
                var n = m.num, d = m.den;
                if (d == 2)
                    throw new Errors_1.UndefinedError('tan is undefined for ' + symbol.toString());
                else if (d == 3) {
                    retval = (0, Parser_1.parse)('sqrt(3)');
                    c = true;
                }
                else if (d == 4) {
                    retval = new Symbol_1.Symbol(1);
                    c = true;
                }
                else if (d == 6) {
                    retval = (0, Parser_1.parse)('1/sqrt(3)');
                    c = true;
                }
                else
                    retval = (0, Symbol_1.symfunction)('tan', [symbol]);
            }
        }
        if (!retval)
            retval = (0, Symbol_1.symfunction)('tan', [symbol]);
        if (c && (q === 2 || q === 4))
            retval.negate();
        return retval;
    },
    sec: function (symbol) {
        if (Settings_1.Settings.PARSE2NUMBER) {
            if (symbol.isConstant()) {
                if (Settings_1.Settings.USE_BIG) {
                    return new Symbol_1.Symbol(new decimal_js_1.default(1).dividedBy(decimal_js_1.default.cos(symbol.multiplier.toDecimal())));
                }
                return new Symbol_1.Symbol(Math2_1.Math2.sec(symbol.valueOf()));
            }
            if (symbol.isImaginary())
                return Complex_1.Complex.evaluate(symbol, 'sec');
            return (0, Parser_1.parse)((0, Utils_1.format)('1/cos({0})', symbol));
        }
        var retval, c = false, q = (0, Frac_1.getQuadrant)(symbol.multiplier.toDecimal()), m = symbol.multiplier.abs();
        symbol.multiplier = m;
        if (symbol.isPi() && symbol.isLinear()) {
            //return for 1 or -1 for multiples of pi
            if ((0, Utils_1.isInt)(m)) {
                retval = new Symbol_1.Symbol((0, Utils_1.even)(m) ? 1 : -1);
            }
            else {
                var n = m.num, d = m.den;
                if (d == 2)
                    throw new Errors_1.UndefinedError('sec is undefined for ' + symbol.toString());
                else if (d == 3) {
                    retval = new Symbol_1.Symbol(2);
                    c = true;
                }
                else if (d == 4) {
                    retval = (0, Parser_1.parse)('sqrt(2)');
                    c = true;
                }
                else if (d == 6) {
                    retval = (0, Parser_1.parse)('2/sqrt(3)');
                    c = true;
                }
                else
                    retval = (0, Symbol_1.symfunction)('sec', [symbol]);
            }
        }
        if (c && (q === 2 || q === 3))
            retval.negate();
        if (!retval)
            retval = (0, Symbol_1.symfunction)('sec', [symbol]);
        return retval;
    },
    csc: function (symbol) {
        if (Settings_1.Settings.PARSE2NUMBER) {
            if (symbol.isConstant()) {
                if (Settings_1.Settings.USE_BIG) {
                    return new Symbol_1.Symbol(new decimal_js_1.default(1).dividedBy(decimal_js_1.default.sin(symbol.multiplier.toDecimal())));
                }
                return new Symbol_1.Symbol(Math2_1.Math2.csc(symbol.valueOf()));
            }
            if (symbol.isImaginary())
                return Complex_1.Complex.evaluate(symbol, 'csc');
            return (0, Parser_1.parse)((0, Utils_1.format)('1/sin({0})', symbol));
        }
        var retval, c = false, q = (0, Frac_1.getQuadrant)(symbol.multiplier.toDecimal()), sign = symbol.multiplier.sign(), m = symbol.multiplier.abs();
        symbol.multiplier = m;
        if (symbol.isPi() && symbol.isLinear()) {
            //return for 0 for multiples of pi
            if ((0, Utils_1.isInt)(m)) {
                throw new Errors_1.UndefinedError('csc is undefined for ' + symbol.toString());
            }
            else {
                var n = m.num, d = m.den;
                if (d == 2) {
                    retval = new Symbol_1.Symbol(1);
                    c = true;
                }
                else if (d == 3) {
                    retval = (0, Parser_1.parse)('2/sqrt(3)');
                    c = true;
                }
                else if (d == 4) {
                    retval = (0, Parser_1.parse)('sqrt(2)');
                    c = true;
                }
                else if (d == 6) {
                    retval = new Symbol_1.Symbol(2);
                    c = true;
                }
                else
                    retval = (0, Core_1.multiply)(new Symbol_1.Symbol(sign), (0, Symbol_1.symfunction)('csc', [symbol]));
            }
        }
        if (!retval)
            retval = (0, Core_1.multiply)(new Symbol_1.Symbol(sign), (0, Symbol_1.symfunction)('csc', [symbol]));
        if (c && (q === 3 || q === 4))
            retval.negate();
        return retval;
    },
    cot: function (symbol) {
        if (Settings_1.Settings.PARSE2NUMBER) {
            if (symbol % (Math.PI / 2) === 0) {
                return new Symbol_1.Symbol(0);
            }
            if (symbol.isConstant()) {
                if (Settings_1.Settings.USE_BIG) {
                    return new Symbol_1.Symbol(new decimal_js_1.default(1).dividedBy(decimal_js_1.default.tan(symbol.multiplier.toDecimal())));
                }
                return new Symbol_1.Symbol(Math2_1.Math2.cot(symbol.valueOf()));
            }
            if (symbol.isImaginary())
                return Complex_1.Complex.evaluate(symbol, 'cot');
            return (0, Parser_1.parse)((0, Utils_1.format)('1/tan({0})', symbol));
        }
        var retval, c = false, q = (0, Frac_1.getQuadrant)(symbol.multiplier.toDecimal()), m = symbol.multiplier;
        symbol.multiplier = m;
        if (symbol.isPi() && symbol.isLinear()) {
            //return 0 for all multiples of pi
            if ((0, Utils_1.isInt)(m)) {
                throw new Errors_1.UndefinedError('cot is undefined for ' + symbol.toString());
            }
            else {
                var n = m.num, d = m.den;
                if (d == 2)
                    retval = new Symbol_1.Symbol(0);
                else if (d == 3) {
                    retval = (0, Parser_1.parse)('1/sqrt(3)');
                    c = true;
                }
                else if (d == 4) {
                    retval = new Symbol_1.Symbol(1);
                    c = true;
                }
                else if (d == 6) {
                    retval = (0, Parser_1.parse)('sqrt(3)');
                    c = true;
                }
                else
                    retval = (0, Symbol_1.symfunction)('cot', [symbol]);
            }
        }
        if (!retval)
            retval = (0, Symbol_1.symfunction)('cot', [symbol]);
        if (c && (q === 2 || q === 4))
            retval.negate();
        return retval;
    },
    acos: function (symbol) {
        if (Settings_1.Settings.PARSE2NUMBER) {
            if (symbol.isConstant()) {
                // Handle values in the complex domain
                if (symbol.gt(1) || symbol.lt(-1)) {
                    var x = symbol.toString();
                    return (0, expand_1.expand)((0, Parser_1.evaluate)(`pi/2-asin(${x})`));
                }
                // Handle big numbers
                if (Settings_1.Settings.USE_BIG) {
                    return new Symbol_1.Symbol(decimal_js_1.default.acos(symbol.multiplier.toDecimal()));
                }
                return new Symbol_1.Symbol(Math.acos(symbol.valueOf()));
            }
            if (symbol.isImaginary())
                return Complex_1.Complex.evaluate(symbol, 'acos');
        }
        return (0, Symbol_1.symfunction)('acos', arguments);
    },
    asin: function (symbol) {
        if (Settings_1.Settings.PARSE2NUMBER) {
            if (symbol.isConstant()) {
                // Handle values in the complex domain
                if (symbol.gt(1) || symbol.lt(-1)) {
                    var i = Settings_1.Settings.IMAGINARY;
                    var x = symbol.multiplier.toDecimal();
                    return (0, expand_1.expand)((0, Parser_1.evaluate)(`${i}*log(sqrt(1-${x}^2)-${i}*${x})`));
                }
                // Handle big numbers
                if (Settings_1.Settings.USE_BIG) {
                    return new Symbol_1.Symbol(decimal_js_1.default.asin(symbol.multiplier.toDecimal()));
                }
                return new Symbol_1.Symbol(Math.asin(symbol.valueOf()));
            }
            if (symbol.isImaginary())
                return Complex_1.Complex.evaluate(symbol, 'asin');
        }
        return (0, Symbol_1.symfunction)('asin', arguments);
    },
    atan: function (symbol) {
        var retval;
        if (symbol.equals(0))
            retval = new Symbol_1.Symbol(0);
        else if (Settings_1.Settings.PARSE2NUMBER) {
            if (symbol.isConstant()) {
                // Handle big numbers
                if (Settings_1.Settings.USE_BIG) {
                    return new Symbol_1.Symbol(decimal_js_1.default.atan(symbol.multiplier.toDecimal()));
                }
                return new Symbol_1.Symbol(Math.atan(symbol.valueOf()));
            }
            if (symbol.isImaginary())
                return Complex_1.Complex.evaluate(symbol, 'atan');
            return (0, Symbol_1.symfunction)('atan', arguments);
        }
        else if (symbol.equals(-1))
            retval = (0, Parser_1.parse)('-pi/4');
        else
            retval = (0, Symbol_1.symfunction)('atan', arguments);
        return retval;
    },
    asec: function (symbol) {
        if (Settings_1.Settings.PARSE2NUMBER) {
            if (symbol.equals(0)) {
                throw new Errors_1.OutOfFunctionDomainError('Input is out of the domain of sec!');
            }
            if (symbol.isConstant()) {
                return exports.Trig.acos(symbol.invert());
            }
            if (symbol.isImaginary()) {
                return Complex_1.Complex.evaluate(symbol, 'asec');
            }
        }
        return (0, Symbol_1.symfunction)('asec', arguments);
    },
    acsc: function (symbol) {
        if (Settings_1.Settings.PARSE2NUMBER) {
            if (symbol.isConstant()) {
                return exports.Trig.asin(symbol.invert());
            }
            if (symbol.isImaginary())
                return Complex_1.Complex.evaluate(symbol, 'acsc');
        }
        return (0, Symbol_1.symfunction)('acsc', arguments);
    },
    acot: function (symbol) {
        if (Settings_1.Settings.PARSE2NUMBER) {
            if (symbol.isConstant()) {
                return new Core_1.add((0, Parser_1.parse)('pi/2'), exports.Trig.atan(symbol).negate());
            }
            if (symbol.isImaginary())
                return Complex_1.Complex.evaluate(symbol, 'acot');
        }
        return (0, Symbol_1.symfunction)('acot', arguments);
    },
    atan2: function (a, b) {
        if (a.equals(0) && b.equals(0))
            throw new Errors_1.UndefinedError('atan2 is undefined for 0, 0');
        if (Settings_1.Settings.PARSE2NUMBER && a.isConstant() && b.isConstant()) {
            return new Symbol_1.Symbol(Math.atan2(a, b));
        }
        return (0, Symbol_1.symfunction)('atan2', arguments);
    }
};
//# sourceMappingURL=Trig.js.map