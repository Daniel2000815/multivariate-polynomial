"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.abs = void 0;
const Symbol_1 = require("../../../Types/Symbol");
const add_1 = require("../operations/add");
const Utils_1 = require("../../../Core/Utils");
const Math2_1 = require("../../Math2");
const Frac_1 = require("../../../Types/Frac");
const Settings_1 = require("../../../Settings");
const index_1 = require("../index");
const Parser_1 = require("../../../Parser/Parser");
function abs(symbol) {
    //|-∞| = ∞
    if (symbol.isInfinity) {
        return Symbol_1.Symbol.infinity();
    }
    if (symbol.multiplier.lessThan(0))
        symbol.multiplier.negate();
    if (symbol.isImaginary()) {
        var re = symbol.realpart();
        var im = symbol.imagpart();
        if (re.isConstant() && im.isConstant())
            return (0, index_1.sqrt)((0, add_1.add)((0, index_1.pow)(re, new Symbol_1.Symbol(2)), (0, index_1.pow)(im, new Symbol_1.Symbol(2))));
    }
    else if ((0, Utils_1.isNumericSymbol)(symbol) || (0, Utils_1.even)(symbol.power)) {
        return symbol;
    }
    if (symbol.isComposite()) {
        var ms = [];
        symbol.each(function (x) {
            ms.push(x.multiplier);
        });
        var gcd = Math2_1.Math2.QGCD.apply(null, ms);
        if (gcd.lessThan(0)) {
            symbol.multiplier = symbol.multiplier.multiply(new Frac_1.Frac(-1));
            symbol.distributeMultiplier();
        }
    }
    //convert |n*x| to n*|x|
    var m = (0, Parser_1.parse)(symbol.multiplier);
    symbol.toUnitMultiplier();
    return (0, index_1.multiply)(m, (0, Symbol_1.symfunction)(Settings_1.Settings.ABS, [symbol]));
}
exports.abs = abs;
//# sourceMappingURL=abs.js.map