"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pfactor = void 0;
const Symbol_1 = require("../../../Types/Symbol");
const Utils_1 = require("../../../Core/Utils");
const Math2_1 = require("../../Math2");
const Frac_1 = require("../../../Types/Frac");
const index_1 = require("../index");
const Parser_1 = require("../../../Parser/Parser");
function pfactor(symbol) {
    //Fix issue #458 | nerdamer("sqrt(1-(3.3333333550520926e-7)^2)").evaluate().text()
    //More Big Number issues >:(
    if (symbol.greaterThan(9.999999999998891e+41) || symbol.equals(-1))
        return symbol;
    //Fix issue #298
    if (symbol.equals(Math.PI))
        return new Symbol_1.Symbol(Math.PI);
    //evaluate the symbol to merge constants
    symbol = (0, Parser_1.evaluate)(symbol.clone());
    if (symbol.isConstant()) {
        var retval = new Symbol_1.Symbol(1);
        var m = symbol.toString();
        if ((0, Utils_1.isInt)(m)) {
            var factors = Math2_1.Math2.ifactor(m);
            for (var factor in factors) {
                var p = factors[factor];
                retval = (0, index_1.multiply)(retval, (0, Symbol_1.symfunction)('parens', [new Symbol_1.Symbol(factor).setPower(new Frac_1.Frac(p))]));
            }
        }
        else {
            var n = pfactor(new Symbol_1.Symbol(symbol.multiplier.num));
            var d = pfactor(new Symbol_1.Symbol(symbol.multiplier.den));
            retval = (0, index_1.multiply)((0, Symbol_1.symfunction)('parens', [n]), (0, Symbol_1.symfunction)('parens', [d]).invert());
        }
    }
    else
        retval = (0, Symbol_1.symfunction)('pfactor', arguments);
    return retval;
}
exports.pfactor = pfactor;
//# sourceMappingURL=pfactor.js.map