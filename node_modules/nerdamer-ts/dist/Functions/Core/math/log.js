"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.log = void 0;
const Symbol_1 = require("../../../Types/Symbol");
const Settings_1 = require("../../../Settings");
const Errors_1 = require("../../../Core/Errors");
const Complex_1 = require("../../Complex");
const Groups_1 = require("../../../Types/Groups");
const add_1 = require("../operations/add");
const index_1 = require("../index");
const Utils_1 = require("../../../Core/Utils");
const Parser_1 = require("../../../Parser/Parser");
/**
 * The log function
 * @param {Symbol} symbol
 * @param {Symbol} base
 * @returns {Symbol}
 */
function log(symbol, base) {
    if (symbol.equals(1)) {
        return new Symbol_1.Symbol(0);
    }
    var retval;
    if (symbol.fname === Settings_1.Settings.SQRT && symbol.multiplier.equals(1)) {
        retval = (0, index_1.divide)(log(symbol.args[0]), new Symbol_1.Symbol(2));
        if (symbol.power.sign() < 0) {
            retval.negate();
        }
        // Exit early
        return retval;
    }
    //log(0) is undefined so complain
    if (symbol.equals(0)) {
        throw new Errors_1.UndefinedError(Settings_1.Settings.LOG + '(0) is undefined!');
    }
    //deal with imaginary values
    if (symbol.isImaginary()) {
        return Complex_1.Complex.evaluate(symbol, Settings_1.Settings.LOG);
    }
    if (symbol.isConstant() && typeof base !== 'undefined' && base.isConstant()) {
        var log_sym = Math.log(symbol);
        var log_base = Math.log(base);
        retval = new Symbol_1.Symbol(log_sym / log_base);
    }
    else if (symbol.group === Groups_1.Groups.EX && symbol.power.multiplier.lessThan(0) || symbol.power.toString() === '-1') {
        symbol.power.negate();
        //move the negative outside but keep the positive inside :)
        retval = log(symbol).negate();
    }
    else if (symbol.value === 'e' && symbol.multiplier.equals(1)) {
        var p = symbol.power;
        retval = (0, Utils_1.isSymbol)(p) ? p : new Symbol_1.Symbol(p);
    }
    else if (symbol.group === Groups_1.Groups.FN && symbol.fname === 'exp') {
        var s = symbol.args[0];
        if (symbol.multiplier.equals(1))
            retval = (0, index_1.multiply)(s, new Symbol_1.Symbol(symbol.power));
        else
            retval = (0, Symbol_1.symfunction)(Settings_1.Settings.LOG, [symbol]);
    }
    else if (Settings_1.Settings.PARSE2NUMBER && (0, Utils_1.isNumericSymbol)(symbol)) {
        // Parse for safety.
        symbol = (0, Parser_1.parse)(symbol);
        var img_part;
        if (symbol.multiplier.lessThan(0)) {
            symbol.negate();
            img_part = (0, index_1.multiply)(new Symbol_1.Symbol(Math.PI), new Symbol_1.Symbol('i'));
        }
        retval = new Symbol_1.Symbol(Math.log(symbol.multiplier.toDecimal()));
        if (img_part) {
            retval = (0, add_1.add)(retval, img_part);
        }
    }
    else {
        var s;
        if (!symbol.power.equals(1) && !symbol.contains('e')) {
            s = symbol.group === Groups_1.Groups.EX ? symbol.power : new Symbol_1.Symbol(symbol.power);
            symbol.toLinear();
        }
        //log(a,a) = 1 since the base is allowed to be changed.
        //This was pointed out by Happypig375 in issue #280
        if (arguments.length > 1 && allSame(arguments)) {
            retval = new Symbol_1.Symbol(1);
        }
        else {
            retval = (0, Symbol_1.symfunction)(Settings_1.Settings.LOG, arguments);
        }
        if (s)
            retval = (0, index_1.multiply)(s, retval);
    }
    return retval;
}
exports.log = log;
//# sourceMappingURL=log.js.map