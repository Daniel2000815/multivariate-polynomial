"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nthroot = void 0;
const Utils_1 = require("../../../Core/Utils");
const abs_1 = require("./abs");
const Frac_1 = require("../../../Types/Frac");
const Math2_1 = require("../../Math2");
const Symbol_1 = require("../../../Types/Symbol");
const Errors_1 = require("../../../Core/Errors");
const index_1 = require("../index");
const Groups_1 = require("../../../Types/Groups");
const Parser_1 = require("../../../Parser/Parser");
/**
 *
 * @param {Symbol} num - the number being raised
 * @param {Symbol} p - the exponent
 * @param {type} prec - the precision wanted
 * @param {bool} asbig - true if a bigDecimal is wanted
 * @returns {Symbol}
 */
function nthroot(num, p, prec, asbig) {
    //clone p and convert to a number if possible
    p = (0, Parser_1.evaluate)((0, Parser_1.parse)(p));
    //cannot calculate if p = 0. nthroot(0, 0) => 0^(1/0) => undefined
    if (p.equals(0)) {
        throw new Errors_1.UndefinedError('Unable to calculate nthroots of zero');
    }
    //Stop computation if it negative and even since we have an imaginary result
    if (num < 0 && (0, Utils_1.even)(p))
        throw new Error('Cannot calculate nthroot of negative number for even powers');
    //return non numeric values unevaluated
    if (!num.isConstant(true)) {
        return (0, Symbol_1.symfunction)('nthroot', arguments);
    }
    //evaluate numeric values
    if (num.group !== Groups_1.Groups.N) {
        num = (0, Parser_1.evaluate)(num);
    }
    //default is to return a big value
    if (typeof asbig === 'undefined')
        asbig = true;
    prec = prec || 25;
    var sign = num.sign();
    var ans;
    if (sign < 0) {
        num = (0, abs_1.abs)(num); //remove the sign
    }
    if ((0, Utils_1.isInt)(num) && p.isConstant()) {
        if (num < 18446744073709551616) {
            //2^64
            ans = Frac_1.Frac.create(Math.pow(num, 1 / p));
        }
        else {
            ans = Math2_1.Math2.nthroot(num, p);
        }
        var retval;
        if (asbig) {
            // FIXME: unused retval
            retval = new Symbol_1.Symbol(ans);
        }
        retval = new Symbol_1.Symbol(ans.toDecimal(prec));
        return (0, index_1.multiply)(new Symbol_1.Symbol(sign), retval);
    }
}
exports.nthroot = nthroot;
//# sourceMappingURL=nthroot.js.map