"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.factorial = void 0;
const Vector_1 = require("../../../Types/Vector");
const Matrix_1 = require("../../../Types/Matrix");
const Settings_1 = require("../../../Settings");
const Utils_1 = require("../../../Core/Utils");
const Math2_1 = require("../../Math2");
const Frac_1 = require("../../../Types/Frac");
const add_1 = require("../operations/add");
const Symbol_1 = require("../../../Types/Symbol");
const index_1 = require("../index");
const Parser_1 = require("../../../Parser/Parser");
/**
 * The factorial function
 * @param {Symbol} symbol
 * @return {Symbol}
 */
function factorial(symbol) {
    var retval;
    if ((0, Utils_1.isVector)(symbol)) {
        var V = new Vector_1.Vector();
        symbol.each(function (x, i) {
            //i start at one.
            V.set(i - 1, factorial(x));
        });
        return V;
    }
    if ((0, Utils_1.isMatrix)(symbol)) {
        var M = new Matrix_1.Matrix();
        symbol.each(function (x, i, j) {
            //i start at one.
            M.set(i, j, factorial(x));
        });
        return M;
    }
    if (Settings_1.Settings.PARSE2NUMBER && symbol.isConstant()) {
        if ((0, Utils_1.isInt)(symbol)) {
            retval = Math2_1.Math2.bigfactorial(symbol);
        }
        else {
            retval = Math2_1.Math2.gamma(symbol.multiplier.add(new Frac_1.Frac(1)).toDecimal());
        }
        retval = (0, Symbol_1.bigConvert)(retval);
        return retval;
    }
    else if (symbol.isConstant()) {
        var den = symbol.getDenom();
        if (den.equals(2)) {
            var num = symbol.getNum();
            var a, b, c, n;
            if (!symbol.multiplier.isNegative()) {
                n = (0, add_1.add)(num, new Symbol_1.Symbol(1)).multiplier.divide(new Frac_1.Frac(2));
                a = Math2_1.Math2.bigfactorial(new Frac_1.Frac(2).multiply(n));
                b = (0, index_1.pow)(new Symbol_1.Symbol(4), new Symbol_1.Symbol(n)).multiplier.multiply(Math2_1.Math2.bigfactorial(n));
            }
            else {
                n = (0, index_1.subtract)(num.negate(), new Symbol_1.Symbol(1)).multiplier.divide(new Frac_1.Frac(2));
                a = (0, index_1.pow)(new Symbol_1.Symbol(-4), new Symbol_1.Symbol(n)).multiplier.multiply(Math2_1.Math2.bigfactorial(n));
                b = Math2_1.Math2.bigfactorial(new Frac_1.Frac(2).multiply(n));
            }
            c = a.divide(b);
            return (0, index_1.multiply)((0, Parser_1.parse)('sqrt(pi)'), new Symbol_1.Symbol(c));
        }
    }
    return (0, Symbol_1.symfunction)(Settings_1.Settings.FACTORIAL, [symbol]);
}
exports.factorial = factorial;
//# sourceMappingURL=factorial.js.map