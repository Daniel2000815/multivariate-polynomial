"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.divide = void 0;
const Errors_1 = require("../../../Core/Errors");
const Matrix_1 = require("../../../Types/Matrix");
const index_1 = require("../index");
const Utils_1 = require("../../../Core/Utils");
/**
 * Gets called when the parser finds the / operator. See this.add
 * @param {Symbol} a
 * @param {Symbol} b
 * @returns {Symbol}
 */
function divide(a, b) {
    var aIsSymbol = (0, Utils_1.isSymbol)(a), bIsSymbol = (0, Utils_1.isSymbol)(b);
    if (aIsSymbol && bIsSymbol) {
        //forward to Unit division
        if (a.unit || b.unit) {
            return deps.Unit.divide(a, b);
        }
        var result;
        if (b.equals(0))
            throw new Errors_1.DivisionByZero('Division by zero not allowed!');
        if (a.isConstant() && b.isConstant()) {
            result = a.clone();
            result.multiplier = result.multiplier.divide(b.multiplier);
        }
        else {
            b.invert();
            result = (0, index_1.multiply)(a, b);
        }
        return result;
    }
    else {
        //******* Vectors & Matrices *********//
        var isVectorA = (0, Utils_1.isVector)(a), isVectorB = (0, Utils_1.isVector)(b);
        if (aIsSymbol && isVectorB) {
            b = b.map(function (x) {
                return divide(a.clone(), x);
            });
        }
        else if (isVectorA && bIsSymbol) {
            b = a.map(function (x) {
                return divide(x, b.clone());
            });
        }
        else if (isVectorA && isVectorB) {
            if (a.dimensions() === b.dimensions()) {
                b = b.map(function (x, i) {
                    return divide(a.elements[--i], x);
                });
            }
            else
                (0, Errors_1.err)('Cannot divide vectors. Dimensions do not match!');
        }
        else {
            var isMatrixA = (0, Utils_1.isMatrix)(a), isMatrixB = (0, Utils_1.isMatrix)(b);
            if (isMatrixA && bIsSymbol) {
                var M = new Matrix_1.Matrix();
                a.eachElement(function (x, i, j) {
                    M.set(i, j, divide(x, b.clone()));
                });
                b = M;
            }
            else if (aIsSymbol && isMatrixB) {
                var M = new Matrix_1.Matrix();
                b.eachElement(function (x, i, j) {
                    M.set(i, j, divide(a.clone(), x));
                });
                b = M;
            }
            else if (isMatrixA && isMatrixB) {
                var M = new Matrix_1.Matrix();
                if (a.rows() === b.rows() && a.cols() === b.cols()) {
                    a.eachElement(function (x, i, j) {
                        M.set(i, j, divide(x, b.elements[i][j]));
                    });
                    b = M;
                }
                else {
                    (0, Errors_1.err)('Dimensions do not match!');
                }
            }
            else if (isMatrixA && isVectorB) {
                if (a.cols() === b.dimensions()) {
                    var M = new Matrix_1.Matrix();
                    a.eachElement(function (x, i, j) {
                        M.set(i, j, divide(x, b.elements[i].clone()));
                    });
                    b = M;
                }
                else {
                    (0, Errors_1.err)('Unable to divide matrix by vector.');
                }
            }
        }
        return b;
    }
}
exports.divide = divide;
//# sourceMappingURL=divide.js.map