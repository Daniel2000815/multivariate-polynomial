"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Complex = void 0;
const Symbol_1 = require("../Types/Symbol");
const Settings_1 = require("../Settings");
const decimal_js_1 = __importDefault(require("decimal.js"));
const Math2_1 = require("./Math2");
const Utils_1 = require("../Core/Utils");
const Core_1 = require("./Core");
const expand_1 = require("./Core/math/expand");
const Parser_1 = require("../Parser/Parser");
//object for functions which handle complex number
exports.Complex = {
    prec: undefined,
    cos: function (r, i) {
        var re, im;
        re = (0, Parser_1.parse)(Math.cos(r) * Math.cosh(i));
        im = (0, Parser_1.parse)(Math.sin(r) * Math.sinh(i));
        return (0, Core_1.subtract)(re, (0, Core_1.multiply)(im, Symbol_1.Symbol.imaginary()));
    },
    sin: function (r, i) {
        var re, im;
        re = (0, Parser_1.parse)(Math.sin(r) * Math.cosh(i));
        im = (0, Parser_1.parse)(Math.cos(r) * Math.sinh(i));
        return (0, Core_1.subtract)(re, (0, Core_1.multiply)(im, Symbol_1.Symbol.imaginary()));
    },
    tan: function (r, i) {
        var re, im;
        re = (0, Parser_1.parse)(Math.sin(2 * r) / (Math.cos(2 * r) + Math.cosh(2 * i)));
        im = (0, Parser_1.parse)(Math.sinh(2 * i) / (Math.cos(2 * r) + Math.cosh(2 * i)));
        return (0, Core_1.add)(re, (0, Core_1.multiply)(im, Symbol_1.Symbol.imaginary()));
    },
    sec: function (r, i) {
        var t = this.removeDen(this.cos(r, i));
        return (0, Core_1.subtract)(t[0], (0, Core_1.multiply)(t[1], Symbol_1.Symbol.imaginary()));
    },
    csc: function (r, i) {
        var t = this.removeDen(this.sin(r, i));
        return (0, Core_1.add)(t[0], (0, Core_1.multiply)(t[1], Symbol_1.Symbol.imaginary()));
    },
    cot: function (r, i) {
        var t = this.removeDen(this.tan(r, i));
        return (0, Core_1.subtract)(t[0], (0, Core_1.multiply)(t[1], Symbol_1.Symbol.imaginary()));
    },
    acos: function (r, i) {
        var symbol, sq, a, b, c, squared;
        symbol = this.fromArray([r, i]);
        squared = (0, Core_1.pow)(symbol.clone(), new Symbol_1.Symbol(2));
        sq = (0, expand_1.expand)(squared); //z*z
        a = (0, Core_1.multiply)((0, Core_1.sqrt)((0, Core_1.subtract)(new Symbol_1.Symbol(1), sq)), Symbol_1.Symbol.imaginary());
        b = (0, expand_1.expand)((0, Core_1.add)(symbol.clone(), a));
        c = (0, Core_1.log)(b);
        return (0, expand_1.expand)((0, Core_1.multiply)(Symbol_1.Symbol.imaginary().negate(), c));
    },
    asin: function (r, i) {
        return (0, Core_1.subtract)((0, Parser_1.parse)('pi/2'), this.acos(r, i));
    },
    atan: function (r, i) {
        // Handle i and -i
        if (r.equals(0) && (i.equals(1) || i.equals(-1))) {
            // Just copy Wolfram Alpha for now. The parenthesis
            return (0, Parser_1.parse)(`${Symbol_1.Symbol.infinity()}*${Settings_1.Settings.IMAGINARY}*${i}`);
        }
        var a, b, c, symbol;
        symbol = exports.Complex.fromArray([r, i]);
        a = (0, expand_1.expand)((0, Core_1.multiply)(Symbol_1.Symbol.imaginary(), symbol.clone()));
        b = (0, Core_1.log)((0, expand_1.expand)((0, Core_1.subtract)(new Symbol_1.Symbol(1), a.clone())));
        c = (0, Core_1.log)((0, expand_1.expand)((0, Core_1.add)(new Symbol_1.Symbol(1), a.clone())));
        return (0, expand_1.expand)((0, Core_1.multiply)((0, Core_1.divide)(Symbol_1.Symbol.imaginary(), new Symbol_1.Symbol(2)), (0, Core_1.subtract)(b, c)));
    },
    asec: function (r, i) {
        var d = this.removeDen([r, i]);
        d[1].negate();
        return this.acos.apply(this, d);
    },
    acsc: function (r, i) {
        var d = this.removeDen([r, i]);
        d[1].negate();
        return this.asin.apply(this, d);
    },
    acot: function (r, i) {
        var d = this.removeDen([r, i]);
        d[1].negate();
        return this.atan.apply(this, d);
    },
    //Hyperbolic trig
    cosh: function (r, i) {
        var re, im;
        re = (0, Parser_1.parse)(Math.cosh(r) * Math.cos(i));
        im = (0, Parser_1.parse)(Math.sinh(r) * Math.sin(i));
        return (0, Core_1.add)(re, (0, Core_1.multiply)(im, Symbol_1.Symbol.imaginary()));
    },
    sinh: function (r, i) {
        var re, im;
        re = (0, Parser_1.parse)(Math.sinh(r) * Math.cos(i));
        im = (0, Parser_1.parse)(Math.cosh(r) * Math.sin(i));
        return (0, Core_1.add)(re, (0, Core_1.multiply)(im, Symbol_1.Symbol.imaginary()));
    },
    tanh: function (r, i) {
        var re, im;
        re = (0, Parser_1.parse)(Math.sinh(2 * r) / (Math.cos(2 * i) + Math.cosh(2 * r)));
        im = (0, Parser_1.parse)(Math.sin(2 * i) / (Math.cos(2 * i) + Math.cosh(2 * r)));
        return (0, Core_1.subtract)(re, (0, Core_1.multiply)(im, Symbol_1.Symbol.imaginary()));
    },
    sech: function (r, i) {
        var t = this.removeDen(this.cosh(r, i));
        return (0, Core_1.subtract)(t[0], (0, Core_1.multiply)(t[1], Symbol_1.Symbol.imaginary()));
    },
    csch: function (r, i) {
        var t = this.removeDen(this.sinh(r, i));
        return (0, Core_1.subtract)(t[0], (0, Core_1.multiply)(t[1], Symbol_1.Symbol.imaginary()));
    },
    coth: function (r, i) {
        var t = this.removeDen(this.tanh(r, i));
        return (0, Core_1.add)(t[0], (0, Core_1.multiply)(t[1], Symbol_1.Symbol.imaginary()));
    },
    acosh: function (r, i) {
        var a, b, z;
        z = this.fromArray([r, i]);
        a = (0, Core_1.sqrt)((0, Core_1.add)(z.clone(), new Symbol_1.Symbol(1)));
        b = (0, Core_1.sqrt)((0, Core_1.subtract)(z.clone(), new Symbol_1.Symbol(1)));
        return (0, expand_1.expand)((0, Core_1.log)((0, Core_1.add)(z, (0, expand_1.expand)((0, Core_1.multiply)(a, b)))));
    },
    asinh: function (r, i) {
        var a, z;
        z = this.fromArray([r, i]);
        a = (0, Core_1.sqrt)((0, Core_1.add)(new Symbol_1.Symbol(1), (0, expand_1.expand)((0, Core_1.pow)(z.clone(), new Symbol_1.Symbol(2)))));
        return (0, expand_1.expand)((0, Core_1.log)((0, Core_1.add)(z, a)));
    },
    atanh: function (r, i) {
        var a, b, z;
        z = this.fromArray([r, i]);
        a = (0, Core_1.log)((0, Core_1.add)(z.clone(), new Symbol_1.Symbol(1)));
        b = (0, Core_1.log)((0, Core_1.subtract)(new Symbol_1.Symbol(1), z));
        return (0, expand_1.expand)((0, Core_1.divide)((0, Core_1.subtract)(a, b), new Symbol_1.Symbol(2)));
    },
    asech: function (r, i) {
        var t = this.removeDen([r, i]);
        t[1].negate();
        return this.acosh.apply(this, t);
    },
    acsch: function (r, i) {
        var t = this.removeDen([r, i]);
        t[1].negate();
        return this.asinh.apply(this, t);
    },
    acoth: function (r, i) {
        var t = this.removeDen([r, i]);
        t[1].negate();
        return this.atanh.apply(this, t);
    },
    sqrt: function (symbol) {
        var re, im, h, a, d;
        re = symbol.realpart();
        im = symbol.imagpart();
        h = Symbol_1.Symbol.hyp(re, im);
        a = (0, Core_1.add)(re.clone(), h);
        d = (0, Core_1.sqrt)((0, Core_1.multiply)(new Symbol_1.Symbol(2), a.clone()));
        return (0, Core_1.add)((0, Core_1.divide)(a.clone(), d.clone()), (0, Core_1.multiply)((0, Core_1.divide)(im, d), Symbol_1.Symbol.imaginary()));
    },
    log: function (r, i) {
        var re, im, phi;
        re = (0, Core_1.log)(Symbol_1.Symbol.hyp(r, i));
        phi = Settings_1.Settings.USE_BIG ? (0, Symbol_1.Symbol)(decimal_js_1.default.atan2(i.multiplier.toDecimal(), r.multiplier.toDecimal())) : Math.atan2(i, r);
        im = (0, Parser_1.parse)(phi);
        return (0, Core_1.add)(re, (0, Core_1.multiply)(Symbol_1.Symbol.imaginary(), im));
    },
    erf(symbol, n) {
        //Do nothing for now. Revisit this in the future.
        return (0, Symbol_1.symfunction)('erf', [symbol]);
        n = n || 30;
        var f = function (R, I) {
            return (0, Utils_1.block)('PARSE2NUMBER', function () {
                var retval = new Symbol_1.Symbol(0);
                for (var i = 0; i < n; i++) {
                    var a, b;
                    a = (0, Parser_1.parse)(decimal_js_1.default.exp((0, decimal_js_1.default)(i).toPower(2).neg().dividedBy((0, decimal_js_1.default)(n).pow(2).plus((0, decimal_js_1.default)(R).toPower(2).times(4)))));
                    b = (0, Parser_1.parse)((0, Utils_1.format)('2*({1})-e^(-(2*{0}*{1}*{2}))*(2*{1}*cosh({2}*{3})-{0}*{3}*sinh({3}*{2}))', Settings_1.Settings.IMAGINARY, R, I, i));
                    retval = (0, Core_1.add)(retval, (0, Core_1.multiply)(a, b));
                }
                return (0, Core_1.multiply)(retval, new Symbol_1.Symbol(2));
            }, true);
        };
        var re, im, a, b, c, k;
        re = symbol.realpart();
        im = symbol.imagpart();
        k = (0, Parser_1.parse)((0, Utils_1.format)('(e^(-{0}^2))/pi', re));
        a = (0, Parser_1.parse)((0, Utils_1.format)('(1-e^(-(2*{0}*{1}*{2})))/(2*{1})', Settings_1.Settings.IMAGINARY, re, im));
        b = f(re.toString(), im.toString());
        return (0, Core_1.add)((0, Parser_1.parse)(Math2_1.Math2.erf(re.toString())), (0, Core_1.multiply)(k, (0, Core_1.add)(a, b)));
    },
    removeDen: function (symbol) {
        var den, r, i, re, im;
        if (Array.isArray(symbol)) {
            r = symbol[0];
            i = symbol[1];
        }
        else {
            r = symbol.realpart();
            i = symbol.imagpart();
        }
        den = Math.pow(r, 2) + Math.pow(i, 2);
        re = (0, Parser_1.parse)(r / den);
        im = (0, Parser_1.parse)(i / den);
        return [re, im];
    },
    fromArray: function (arr) {
        return (0, Core_1.add)(arr[0], (0, Core_1.multiply)(Symbol_1.Symbol.imaginary(), arr[1]));
    },
    evaluate: function (symbol, f) {
        var re, im, sign;
        sign = symbol.power.sign();
        //remove it from under the denominator
        symbol.power = symbol.power.abs();
        //expand
        if (symbol.power.greaterThan(1))
            symbol = (0, expand_1.expand)(symbol);
        //remove the denominator
        if (sign < 0) {
            var d = this.removeDen(symbol);
            re = d[0];
            im = d[1];
        }
        else {
            re = symbol.realpart();
            im = symbol.imagpart();
        }
        if (re.isConstant('all') && im.isConstant('all'))
            return this[f].call(this, re, im);
        return (0, Symbol_1.symfunction)(f, [symbol]);
    }
};
//# sourceMappingURL=Complex.js.map